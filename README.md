# 算法分析

用来估算一个算法所需要的时间。时间复杂度是一个描述算法所需时间如何随着输入的数据量增加而增长的函数（相对增长率）。计算算法的最坏情况复杂度，记为 $T(N)$。这个函数是渐进的，所以只保留最高次项并且省略系数。

## 符号

有以下几个符号来表示时间复杂度，主要常用 $O(f(N))$ 表示。

### $O(f(N))$

表示增长的上界，最坏的情况不会超过（$\le$）函数 $f(N)$ 的增长率。

主要用的就是这个大O表示法

### $\Omega(f(N))$

表示增长的下界。

### $\Theta(f(N))$

表示增长率与指定的函数 $f(N)$ 一样。

### $o(f(N))$

$O(f(N))$ 包含了增长率与 $f(N)$ 相等的情况，$o(f(N))$ 表示 $T(N)$ 的增长率 $\lt$ $f(N)$ 的增长率。

## 简单的判断方法

### $O(1)$

常数时间，无论输入的数据有多少都消耗同样的时间，

如果没有循环，基本上就是这样。

### $O(N)$

线性时间

当有一个循环遍历输入数据，或者多个循环，但不是嵌套的情况，则消耗线性时间。

### $O(N^2)$

当多个循环嵌套在一起时，有几个循环嵌套时间复杂度就是 $O(N^几)$，

多个循环顺序相连，复杂度为最高的层次，

如果有判断出现，选择所有分支中复杂度最高的那个作为最终的结果。

### $O(\log N)$

对数时间比线性时间要快，

二分法查找就是对数时间，而顺序查找是线性时间，

欧基里德算法找最大公因式也是对数时间。

**为什么大O表示法没有前面的系数、没有底数或者没有相加？大O表示法代表的是当数据输入量增长时，算法所需时间的增长速度。所以为了方便忽略它们（其对于时间增长速度的影响远不及乘方或者取对数）。**

# 数据结构

## 线性与非线性

- 线性数据结构只有唯一的首项和末项
- 线性结构除了首项和末项外每个项都有唯一的前驱和后继
- 线性结构可以顺序储存，如数组（ArrayList），也可以链式储存，如链表（LinkedList）

一维数组、链表、栈、队列等是线性结构

多维数组、树、图等是非线性结构

## 数组（表）

### 定长数组（Array）

最基本的数组，编程语言基本上有对应实现。

读写花费常数时间，无法删改。

### 变长数组（ArrayList）

使用定长数组来实现变长数组，通过一个变量来记录 size，并在实际数据量超过定长数组限度时创建一个双倍长度的新定长数组。

在 push 及 get 时消耗常数时间，而在中间插入和删除消耗线性时间。。

### 链表（LinkedList）

### 单向链表（SingleLinkedList）

实现一个单链表需要 `SingleLinkedList` 和 `SingleLinkedListItem` 两个 class。因为表内的每个项目需要维护到下一个项目的引用。最后一项的 `next` 指向 `null`。

链表在中间插入和删除时效率比较高，因为不需要把所有后面的东西都挪一个位置。但是在最后插入和删除比较慢，因为得先一路找到最后一个。

### 双向链表（DoubleLinkedList）

我们可以对单链表做一点更改，让每个 `DoubleLinkedListItem` 不仅链接到它的后一个项，还链接到前一个项，并且在 `DoubleLinkedList` 类中同时包含到第一个和最后一个项的引用，这样就减少了在最后插入和删除时的开销。

表已经涵盖了栈和队列的全部功能，但在一些不需要同时访问全部元素的情况下使用栈或者队列能够更加高效。

## 栈（Stack）

栈模型中只有最顶端的元素可以访问，栈只有 push 和 pop 两种操作，分别是在栈顶添加元素以及移除并返回栈顶元素。有些时候会有 top 操作，是查看栈顶元素，但不返回它。

栈可以像 ArrayList 一样用数组存储，也可以做成链接的方式。如果做成链接，我们只需要存储到栈顶元素的引用，并在每个元素中存储对下一个元素的引用，这两种方法都很高效，并且链式存储的方式比 LinkedList 更高效。

## 队列（Queue）

只能在尾部增加元素，在头部移除元素，因此只有 enqueue 和 dequeue 两种操作。

队列用数组的方式表示的时候，一般做成环状，因为尾部被塞满的时候很可能头部已经空出一些位置，新的数据填入这些位置里，保存队列头部和尾部两个位置的指针。这样如果尾指针小于头指针，就在读到存储用的数组末尾时回到数组最前端继续读，可以跟有效的利用空间，并且插入和删除都只消耗常数时间。

尾指针指向队列尾部元素的下一个空档。

## 树（Tree）

树是一种非线性结构，每个节点可以包含子节点。

当存储普通的树时，一般每个节点维护到第一个子节点和下一个兄弟的引用。

### 二叉树（BinaryTree）

二叉树是每个节点最多只有两个子节点的树。

存储的时候每个节点维护到左子节点和右子节点的引用，也可以作为数组存储。

在二叉树的处理中涉及到很多的递归操作。

#### 二叉树的遍历（Traversal）

有三种遍历树的方式，一般使用的是第二种。

##### Preorder

先看那个节点的 value，再递归遍历左子节点和右子节点（用同样的方法）。

##### Inorder

先左子节点，然后它本身，然后右节点。

##### Postorder

先递归遍历左子节点和右子节点，再读取它本身的 value。

#### 二叉查找树

二叉查找树是一种特殊的二叉树，里面的项都是排列好的，可以很快的从里面查找东西，类似与二分法。（$O(\log N)$）

##### 要求

- 整个树中没有重复的 value

- 在每个节点中，左子节点（如果有） $\lt$ 它本身 $\lt$ 右子节点（如果有）

  也就是说，Inorder Traversal 下来是按顺序的

##### 搜索方式

把节点的 value 与要找的数对比一下，如果小了，那就往右分支找（递归），大了就往左分支找

一路向左走，就能找到最小值，向右走能找到最大值。这个的实现可以用递归，也可以不用

