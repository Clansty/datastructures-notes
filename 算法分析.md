# 算法分析

用来估算一个算法所需要的时间。时间复杂度是一个描述算法所需时间如何随着输入的数据量增加而增长的函数（相对增长率）。计算算法的最坏情况复杂度，记为 $T(N)$。这个函数是渐进的，所以只保留最高次项并且省略系数

## 符号

有以下几个符号来表示时间复杂度，主要常用 $O(f(N))$ 表示

### $O(f(N))$

表示增长的上界，最坏的情况不会超过（$\le$）函数 $f(N)$ 的增长率

### $\Omega(f(N))$

表示增长的下界

### $\Theta(f(N))$

表示增长率与指定的函数 $f(N)$ 一样

### $o(f(N))$

$O(f(N))$ 包含了增长率与 $f(N)$ 相等的情况，$o(f(N))$ 表示 $T(N)$ 的增长率 $\lt$ $f(N)$ 的增长率

## 简单的判断方法

### $O(1)$

常数时间，无论输入的数据有多少都消耗同样的时间

如果没有循环，基本上就是这样

### $O(N)$

线性时间

当有一个循环遍历输入数据，或者多个循环，但不是嵌套的情况，则消耗线性时间

### $O(N^2)$

当多个循环嵌套在一起时，有几个循环嵌套时间复杂度就是 $O(N^几)$

多个循环顺序相连，复杂度为最高的层次（没有 $O(N^2+N^3)$ 这种）

如果有判断出现，选择所有分支中复杂度最高的那个作为最终的结果

### $O(\log N)$

对数时间比线性时间要快

二分法查找就是对数时间，而顺序查找是线性时间

欧基里德算法找最大公因式也是对数时间

# 数据结构

## 表（ArrayList，LinkedList）

### ArrayList

使用定长数组来实现边长数组，通过一个变量来记录 size，并在实际数据量超过定长数组限度时创建一个双倍长度的新定长数组

在 push 及 get 时消耗常数时间，而在

