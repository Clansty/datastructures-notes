# 算法分析

用来估算一个算法所需要的时间。时间复杂度是一个描述算法所需时间如何随着输入的数据量增加而增长的函数（相对增长率）。计算算法的最坏情况复杂度，记为 $T(N)$。这个函数是渐进的，所以只保留最高次项并且省略系数

## 符号

有以下几个符号来表示时间复杂度，主要常用 $O(f(N))$ 表示

### $O(f(N))$

表示增长的上界，最坏的情况不会超过（$\le$）函数 $f(N)$ 的增长率

### $\Omega(f(N))$

表示增长的下界

### $\Theta(f(N))$

表示增长率与指定的函数 $f(N)$ 一样

### $o(f(N))$

$O(f(N))$ 包含了增长率与 $f(N)$ 相等的情况，$o(f(N))$ 表示 $T(N)$ 的增长率 $\lt$ $f(N)$ 的增长率

## 简单的判断方法

### $O(1)$

常数时间，无论输入的数据有多少都消耗同样的时间

如果没有循环，基本上就是这样

### $O(N)$

线性时间

当有一个循环遍历输入数据，或者多个循环，但不是嵌套的情况，则消耗线性时间

### $O(N^2)$

当多个循环嵌套在一起时，有几个循环嵌套时间复杂度就是 $O(N^几)$

多个循环顺序相连，复杂度为最高的层次（没有 $O(N^2+N^3)$ 这种）

如果有判断出现，选择所有分支中复杂度最高的那个作为最终的结果

### $O(\log N)$

对数时间比线性时间要快

二分法查找就是对数时间，而顺序查找是线性时间

欧基里德算法找最大公因式也是对数时间

# 数据结构

## 线性与非线性

- 线性数据结构只有唯一的首项和末项
- 线性结构除了首项和末项外每个项都有唯一的前驱和后继
- 线性结构可以顺序储存（ArrayList），也可以链式储存（LinkedList）

一维数组、队列、链表、栈 是线性结构

多维数组、树、图之类的是非线性结构

## 表（ArrayList，LinkedList）

### ArrayList

使用定长数组来实现边长数组，通过一个变量来记录 size，并在实际数据量超过定长数组限度时创建一个双倍长度的新定长数组

在 push 及 get 时消耗常数时间，而在中间插入和删除消耗线性时间

### 单链表

实现一个单链表需要 `SingleLinkedList` 和 `SingleLinkedListItem` 两个 class。因为表内的每个项目需要维护到下一个项目的引用。最后一项的 `next` 指向 `null`

链表在中间插入和删除时效率比较高，因为不需要把所有后面的东西都挪一个位置。但是在最后插入和删除比较慢，因为得先一路找到最后一个

### 双链表

我们可以对单链表做一点更改，让每个 `DoubleLinkedListItem` 不仅链接到它的后一个项，还链接到前一个项，并且在 `DoubleLinkedList` 类中同时包含到第一个和最后一个项的引用，这样就减少了在最后插入和删除时的开销

表已经涵盖了栈和队列的全部功能，但在一些不需要同时访问全部元素的情况下使用栈或者队列能够更加高效

## 栈

栈模型中只有最顶端的元素可以访问，栈只有 push 和 pop 两种操作，分别是在栈顶添加元素以及移除并返回栈顶元素。有些时候会有 top 操作，是查看栈顶元素，但不返回它

栈可以像 ArrayList 一样用数组存储，也可以做成链接的方式。如果做成链接，我们只需要存储到栈顶元素的引用，并在每个元素中存储对下一个元素的引用，这两种方法都很高效，并且链式存储的方式比 LinkedList 更高效

## 队列

只能在尾部增加元素，在头部移除元素，因此只有 enqueue 和 dequeue 两种操作

队列用数组的方式表示的时候，一般做成环状，因为尾部被塞满的时候很可能头部已经空出一些位置，新的数据填入这些位置里，保存队列头部和尾部两个位置的指针。这样如果尾指针小于头指针，就在读到存储用的数组末尾时回到数组最前端继续读，可以跟有效的利用空间，并且插入和删除都只消耗常数时间

尾指针指向队列尾部元素的下一个空档